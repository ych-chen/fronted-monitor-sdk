<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontend Monitor SDK E2E Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <h1>Frontend Monitor SDK E2E Test Page</h1>

    <div class="test-section">
        <h2>SDK Initialization</h2>
        <button class="button" onclick="initializeSDK()">Initialize SDK</button>
        <button class="button" onclick="destroySDK()">Destroy SDK</button>
        <div id="init-status" class="status info">SDK not initialized</div>
    </div>

    <div class="test-section">
        <h2>Tracing Tests</h2>
        <button class="button" onclick="createSpan()">Create Span</button>
        <button class="button" onclick="createAsyncSpan()">Create Async Span</button>
        <button class="button" onclick="recordError()">Record Error</button>
        <div id="tracing-status" class="status info">No tracing operations performed</div>
    </div>

    <div class="test-section">
        <h2>Metrics Tests</h2>
        <button class="button" onclick="recordCounter()">Increment Counter</button>
        <button class="button" onclick="recordHistogram()">Record Histogram</button>
        <button class="button" onclick="setGauge()">Set Gauge</button>
        <button class="button" onclick="recordBatchMetrics()">Record Batch</button>
        <div id="metrics-status" class="status info">No metrics recorded</div>
    </div>

    <div class="test-section">
        <h2>Auto-Instrumentation Tests</h2>
        <button class="button" onclick="testXHR()">Test XHR Request</button>
        <button class="button" onclick="testFetch()">Test Fetch Request</button>
        <button class="button" onclick="testFailedRequest()">Test Failed Request</button>
        <div id="instrumentation-status" class="status info">No HTTP requests tested</div>
    </div>

    <div class="test-section">
        <h2>User Interaction Tests</h2>
        <button class="button" id="test-button" onclick="recordInteraction()">Record Interaction</button>
        <button class="button" onclick="simulateComplexWorkflow()">Complex Workflow</button>
        <div id="interaction-status" class="status info">No interactions recorded</div>
    </div>

    <div class="test-section">
        <h2>Performance Tests</h2>
        <button class="button" onclick="simulateSlowOperation()">Simulate Slow Operation</button>
        <button class="button" onclick="loadImage()">Load Image</button>
        <div id="performance-status" class="status info">No performance tests</div>
    </div>

    <!-- Load the SDK -->
    <script src="/dist/index.umd.js"></script>

    <script>
        let monitor = null;
        let operationCount = 0;

        // Make SDK available globally for Playwright tests
        window.createFrontendMonitor = FrontendMonitorSDK.createFrontendMonitor;

        function updateStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `status ${type}`;
        }

        async function initializeSDK() {
            try {
                monitor = window.createFrontendMonitor();
                await monitor.init({
                    serviceName: 'e2e-test-service',
                    serviceVersion: '1.0.0',
                    endpoint: 'https://otel-collector.example.com/v1/traces',
                    apiKey: 'test-api-key',
                    sampleRate: 1.0,
                    enableAutoTracing: true,
                    enableCustomMetrics: true,
                    enableErrorMonitoring: true,
                    enableUserInteractionMonitoring: true,
                    enablePerformanceMetrics: true,
                    excludedUrls: ['*.excluded.com'],
                    attributes: {
                        'test.environment': 'e2e',
                        'test.browser': navigator.userAgent
                    }
                });
                updateStatus('init-status', 'SDK initialized successfully', 'success');
            } catch (error) {
                updateStatus('init-status', `SDK initialization failed: ${error.message}`, 'error');
            }
        }

        async function destroySDK() {
            try {
                if (monitor) {
                    await monitor.destroy();
                    monitor = null;
                    updateStatus('init-status', 'SDK destroyed successfully', 'success');
                } else {
                    updateStatus('init-status', 'SDK not initialized', 'error');
                }
            } catch (error) {
                updateStatus('init-status', `SDK destroy failed: ${error.message}`, 'error');
            }
        }

        function createSpan() {
            if (!monitor) {
                updateStatus('tracing-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const tracer = monitor.startTracing(`test-span-${++operationCount}`);
                tracer.endSpan();
                updateStatus('tracing-status', `Created span: test-span-${operationCount}`, 'success');
            } catch (error) {
                updateStatus('tracing-status', `Span creation failed: ${error.message}`, 'error');
            }
        }

        async function createAsyncSpan() {
            if (!monitor) {
                updateStatus('tracing-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const traceManager = monitor.getTraceManager();
                await traceManager.traceAsync(`async-span-${++operationCount}`, async (span) => {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    return 'async-operation-complete';
                });
                updateStatus('tracing-status', `Created async span: async-span-${operationCount}`, 'success');
            } catch (error) {
                updateStatus('tracing-status', `Async span creation failed: ${error.message}`, 'error');
            }
        }

        function recordError() {
            if (!monitor) {
                updateStatus('tracing-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const error = new Error(`Test error ${++operationCount}`);
                monitor.recordError(error, { testContext: 'e2e', operationId: operationCount });
                updateStatus('tracing-status', `Recorded error: ${error.message}`, 'success');
            } catch (error) {
                updateStatus('tracing-status', `Error recording failed: ${error.message}`, 'error');
            }
        }

        function recordCounter() {
            if (!monitor) {
                updateStatus('metrics-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const metricsCollector = monitor.getMetricsCollector();
                metricsCollector.incrementCounter(`e2e-counter-${operationCount}`, 1, { test: 'true' });
                updateStatus('metrics-status', `Incremented counter: e2e-counter-${operationCount}`, 'success');
            } catch (error) {
                updateStatus('metrics-status', `Counter recording failed: ${error.message}`, 'error');
            }
        }

        function recordHistogram() {
            if (!monitor) {
                updateStatus('metrics-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const metricsCollector = monitor.getMetricsCollector();
                metricsCollector.recordHistogram(`e2e-duration-${operationCount}`, Math.random() * 1000);
                updateStatus('metrics-status', `Recorded histogram: e2e-duration-${operationCount}`, 'success');
            } catch (error) {
                updateStatus('metrics-status', `Histogram recording failed: ${error.message}`, 'error');
            }
        }

        function setGauge() {
            if (!monitor) {
                updateStatus('metrics-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const metricsCollector = monitor.getMetricsCollector();
                metricsCollector.setGauge(`e2e-gauge-${operationCount}`, Math.floor(Math.random() * 100));
                updateStatus('metrics-status', `Set gauge: e2e-gauge-${operationCount}`, 'success');
            } catch (error) {
                updateStatus('metrics-status', `Gauge setting failed: ${error.message}`, 'error');
            }
        }

        function recordBatchMetrics() {
            if (!monitor) {
                updateStatus('metrics-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                monitor.recordMetrics({
                    [`batch-counter-${operationCount}`]: 5,
                    [`batch-gauge-${operationCount}`]: 42.5,
                    [`batch-histogram-${operationCount}`]: 250
                });
                updateStatus('metrics-status', `Recorded batch metrics: ${operationCount}`, 'success');
            } catch (error) {
                updateStatus('metrics-status', `Batch recording failed: ${error.message}`, 'error');
            }
        }

        async function testXHR() {
            if (!monitor) {
                updateStatus('instrumentation-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'https://httpbin.org/json');
                xhr.onload = () => {
                    updateStatus('instrumentation-status', 'XHR request completed', 'success');
                };
                xhr.onerror = () => {
                    updateStatus('instrumentation-status', 'XHR request failed', 'error');
                };
                xhr.send();
            } catch (error) {
                updateStatus('instrumentation-status', `XHR test failed: ${error.message}`, 'error');
            }
        }

        async function testFetch() {
            if (!monitor) {
                updateStatus('instrumentation-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const response = await fetch('https://httpbin.org/uuid');
                if (response.ok) {
                    updateStatus('instrumentation-status', 'Fetch request completed', 'success');
                } else {
                    updateStatus('instrumentation-status', 'Fetch request failed', 'error');
                }
            } catch (error) {
                updateStatus('instrumentation-status', `Fetch test failed: ${error.message}`, 'error');
            }
        }

        async function testFailedRequest() {
            if (!monitor) {
                updateStatus('instrumentation-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const response = await fetch('https://httpbin.org/status/500');
                updateStatus('instrumentation-status', `Failed request completed with status: ${response.status}`, 'success');
            } catch (error) {
                updateStatus('instrumentation-status', `Failed request test: ${error.message}`, 'error');
            }
        }

        function recordInteraction() {
            if (!monitor) {
                updateStatus('interaction-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                monitor.recordUserInteraction({
                    type: 'click',
                    element: 'button',
                    target: '#test-button',
                    timestamp: Date.now(),
                    duration: 25
                });
                updateStatus('interaction-status', 'Recorded user interaction: click', 'success');
            } catch (error) {
                updateStatus('interaction-status', `Interaction recording failed: ${error.message}`, 'error');
            }
        }

        async function simulateComplexWorkflow() {
            if (!monitor) {
                updateStatus('interaction-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const traceManager = monitor.getTraceManager();
                await traceManager.traceAsync('complex-workflow', async (span) => {
                    // Record user interaction
                    monitor.recordUserInteraction({
                        type: 'workflow',
                        target: 'complex-workflow',
                        timestamp: Date.now()
                    });

                    // Make HTTP request
                    const response = await fetch('https://httpbin.org/delay/0.2');

                    // Record metrics
                    const metricsCollector = monitor.getMetricsCollector();
                    metricsCollector.incrementCounter('workflows-executed');
                    metricsCollector.recordHistogram('workflow-duration', 200);

                    return response.ok ? 'success' : 'failed';
                });

                updateStatus('interaction-status', 'Complex workflow completed', 'success');
            } catch (error) {
                updateStatus('interaction-status', `Complex workflow failed: ${error.message}`, 'error');
            }
        }

        function simulateSlowOperation() {
            if (!monitor) {
                updateStatus('performance-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const traceManager = monitor.getTraceManager();
                traceManager.trace('slow-operation', () => {
                    // Simulate slow synchronous operation
                    const start = performance.now();
                    while (performance.now() - start < 200) {
                        // Busy wait for 200ms
                    }
                    return 'slow-complete';
                });

                updateStatus('performance-status', 'Slow operation completed (200ms)', 'success');
            } catch (error) {
                updateStatus('performance-status', `Slow operation failed: ${error.message}`, 'error');
            }
        }

        function loadImage() {
            if (!monitor) {
                updateStatus('performance-status', 'SDK not initialized', 'error');
                return;
            }

            try {
                const img = new Image();
                img.onload = () => {
                    updateStatus('performance-status', 'Image loaded successfully', 'success');
                };
                img.onerror = () => {
                    updateStatus('performance-status', 'Image loading failed', 'error');
                };
                img.src = 'https://httpbin.org/image/png';
            } catch (error) {
                updateStatus('performance-status', `Image loading test failed: ${error.message}`, 'error');
            }
        }

        // Auto-initialize for E2E tests
        window.addEventListener('load', () => {
            // Don't auto-initialize, let tests control initialization
            console.log('Test page loaded. Ready for E2E testing.');
        });
    </script>
</body>
</html>